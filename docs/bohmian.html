<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>bohmian API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bohmian</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from scipy import stats
import numpy as np
import matplotlib.pyplot as plt
import fastpotential as fp
from utils import find_nearest,x_deriv, y_deriv
class Trajectory():

    &#34;&#34;&#34;A class describing a single Bohmian trajectory with a given weight.

    Parameters
    ----------
    psi0 : 2 dimensional complex ndarray
        The initial wave function to start the simulation from.
    x : 1 dimensional double ndarray
        The grid points for the box along one dimensional. The other dimension is forced to be the same
    L : double
        Half the length of the box.
    coeffs : 2 dimensional complex ndarray
        The coefficients for the basis expansion of psi.
    Nt : integer
        Number of timesteps to take
    dt : double
        Size of the timestep
    startind : integer tuple
        The starting position index from the x-array. 
    weight : integer
        How many trajectories start from the same index.
    
    Notes
    -----
    The class computes the trajectory only on command; by default, it contains some information about the weight of the trajectory
    (i.e. how many times the particle started in the initial position), the inital wave function and the coefficient required for
    the expansion. 
    &#34;&#34;&#34;
    def __init__(self, psi0, x, L, coeffs, Nt, dt, startind, weight):
        self.weight = weight
        self.x = x
        self.pos = np.array([x[startind[0]],x[startind[1]]])
        self.dx = self.x[1]-self.x[0]
        self.dt = dt
        self.psi0 = psi0
        self.traj = [self.pos]
        self.Nt = Nt
        self.L = L
        self.coeffs = coeffs
        self.n_basis = len(coeffs[:,0])
    def plot_xs(self):
        &#34;&#34;&#34;this is a description of the plot thing.&#34;&#34;&#34;
        ntraj = np.array(self.traj)
        print(np.max(ntraj[:,0]))
        print(ntraj[:,0])
    
    def euler_step(self,step):
        xcoord = find_nearest(self.x,self.pos[0])
        ycoord = find_nearest(self.x,self.pos[1])
        psi = self.psis[:,:,step]
        k1 = np.nan_to_num((x_deriv(psi,xcoord,ycoord,self.dx)/psi[xcoord,ycoord]).imag )
        k2 = np.nan_to_num((y_deriv(psi,xcoord,ycoord,self.dx)/psi[xcoord,ycoord]).imag )
        return [self.pos[0] + self.dt * k1, self.pos[1] + self.dt * k2]

    def euler_step_cython(self):
        &#34;&#34;&#34;Take Euler method step in the trajectory calculation.

        Returns
        -------
        pos : tuple (double)
            The new coordinates of the particle in (x1,x2) space.

        &#34;&#34;&#34;
        x1 = self.pos[0]
        x2 = self.pos[1]
        psi = 0
        k1 = np.nan_to_num( (fp.basis2d_x1deriv(self.coeffs, x1, x2, self.L, self.n_basis)/psi).imag  )
        k2 = np.nan_to_num( (fp.basis2d_x2deriv(self.coeffs, x1, x2, self.L, self.n_basis)/psi).imag )
        return [self.pos[0] + self.dt * k1, self.pos[1] + self.dt * k2]
    
    def compute_trajectory(self):
        &#34;&#34;&#34;Computes the trajectory for Nt time steps.
        
        Notes
        -----
        This is an internal function that modifies the trajectory self.traj. That variable contains
        as a numpy array the positions of the particle at each timestamp.
        &#34;&#34;&#34;
        for i in range(self.Nt):
            self.pos = self.euler_step(i)
            self.traj.append(np.copy(self.pos))

    def get_trajectory(self):
        &#34;&#34;&#34;Returns the trajectory as a numpy array.
        
        Returns
        -------
        traj : 2 dimensional ndarray
            The trajectory.
        &#34;&#34;&#34;
        return np.array(self.traj)

    def get_weight(self):
        &#34;&#34;&#34;Returns the weight of this trajectory
        
        Returns
        -------
        weight : integer
            The weight of the trajectory, i.e. how many times the particle started at this position.
        &#34;&#34;&#34;
        return self.weight

class BohmianSimulation():
    &#34;&#34;&#34; A class containing a full Bohmian simulation. It simulates a given number of trajectories when given a coefficient file
    for the basis expansion of the wave function. The trajectories are then saved in the file specified by &#34;output&#34; as a .npy 
    file, loadable by numpy. The user should only call the constructor and calculate_trajectories.

    Parameters
    ----------
    psi0 : 2 dimensional complex ndarray
        The initial NORMALIZED wave function for the particles
    x : 1 dimensional double ndarray
        The grid points along one dimension, of length Np
    L : double
        Half the box length
    Nt : integer
        Number of time steps to take
    dt : double
        The length of the time step
    Ntraj : integer
        The number of trajectories to compute, given the initial distribution based on psi0
    coeff_file : string
        The .txt file containing the coefficients for the basis expansion of psi.
    output : string
        The output file, in to which the trajectories are dumped as a numpy array (which can be loaded with np.load).
    
    Notes
    -----
    This code draws from a discrete distribution of initial positions. This is basically equivalent
    to binning the end result distribution, so you might as well do it beforehand. This saves some computation,
    as trajectories starting at the same point need to only be calculated once.
    &#34;&#34;&#34;
    def __init__(self,psi0, x, L, Nt, dt, Ntraj = 1000, coeff_file=&#34;coeffs_nowall.txt&#34;, output=&#34;trajs.npy&#34;):
        self.psi0 = psi0
        self.Np = len(x)
        self.x = x
        self.dx = x[1]-x[0]
        self.Ntraj = Ntraj
        self.dt = dt
        self.Nt = Nt
        self.L = L
        self.coeffs = np.loadtxt(coeff_file, dtype=complex)
        self.output = output
    def generate_initial_distribution(self):
        &#34;&#34;&#34;Generates the initial distribution of indices in the psi0 array. Looks a bit confusing, but easily understood
        by perusing the rv_discrete documentation
        
        Returns
        -------
        dist 
            The collection of indices randomly drawn based on the psi distribution, corresponding to initial starting positions.
        
        Notes
        -----
        Depends on the initial distribution being given, and thus shouldn&#39;t be called outside of the class.
        &#34;&#34;&#34;
        equilibrium = stats.rv_discrete(name=&#39;equilibrium&#39;, values=(np.arange(self.Np*self.Np).reshape((self.Np,self.Np)), np.abs(self.psi0)**2*self.dx*self.dx))
        return equilibrium.rvs(size=self.Ntraj)

    def calculate_trajectories(self):
        &#34;&#34;&#34;Calculates Nt trajectories, giving them weights according to how many particles start at the same position in the initial
        distribution.

        Returns
        -------
        output : .npy file
            The output is given in the form of a .npy file, which can then be later loaded with np.load.
            The file is indexed such that arr[0,:,:] contains the first trajectory, with arr[0,:,0] containing
            the sequence of x1 coordinates and arr[0,0,:] containing the x2 coordinates.
        &#34;&#34;&#34;
        R = self.generate_initial_distribution()
        Rx = np.array([np.count_nonzero(R==y) for y in np.arange(self.Np*self.Np)])
        Rxs = Rx.reshape((self.Np,self.Np)) # This now contains how many 
        trajectories = []
        for i in range(len(Rxs[0,:])):
            for j in range(len(Rxs[0,:])):
                if Rxs[i,j] != 0:
                    trajectories.append(Trajectory(self.psi0, self.x, self.Nt, self.dt, (i,j),  Rxs[i,j]))

        print(&#34;Number of different trajectories: &#34;, len(trajectories), &#34;, starting calculation..&#34;)
        traj_xs = []
        for i in trajectories:
            i.compute_trajectory()
            for k in range(i.get_weight()):
                traj_xs.append(i.get_trajectory())
        
        np.save(self.output,np.array(traj_xs))

if __name__==&#34;__main__&#34;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="bohmian.BohmianSimulation"><code class="flex name class">
<span>class <span class="ident">BohmianSimulation</span></span>
<span>(</span><span>psi0, x, L, Nt, dt, Ntraj=1000, coeff_file='coeffs_nowall.txt', output='trajs.npy')</span>
</code></dt>
<dd>
<div class="desc"><p>A class containing a full Bohmian simulation. It simulates a given number of trajectories when given a coefficient file
for the basis expansion of the wave function. The trajectories are then saved in the file specified by "output" as a .npy
file, loadable by numpy. The user should only call the constructor and calculate_trajectories.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>psi0</code></strong> :&ensp;<code>2 dimensional complex ndarray</code></dt>
<dd>The initial NORMALIZED wave function for the particles</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>1 dimensional double ndarray</code></dt>
<dd>The grid points along one dimension, of length Np</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>double</code></dt>
<dd>Half the box length</dd>
<dt><strong><code>Nt</code></strong> :&ensp;<code>integer</code></dt>
<dd>Number of time steps to take</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>double</code></dt>
<dd>The length of the time step</dd>
<dt><strong><code>Ntraj</code></strong> :&ensp;<code>integer</code></dt>
<dd>The number of trajectories to compute, given the initial distribution based on psi0</dd>
<dt><strong><code>coeff_file</code></strong> :&ensp;<code>string</code></dt>
<dd>The .txt file containing the coefficients for the basis expansion of psi.</dd>
<dt><strong><code>output</code></strong> :&ensp;<code>string</code></dt>
<dd>The output file, in to which the trajectories are dumped as a numpy array (which can be loaded with np.load).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This code draws from a discrete distribution of initial positions. This is basically equivalent
to binning the end result distribution, so you might as well do it beforehand. This saves some computation,
as trajectories starting at the same point need to only be calculated once.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BohmianSimulation():
    &#34;&#34;&#34; A class containing a full Bohmian simulation. It simulates a given number of trajectories when given a coefficient file
    for the basis expansion of the wave function. The trajectories are then saved in the file specified by &#34;output&#34; as a .npy 
    file, loadable by numpy. The user should only call the constructor and calculate_trajectories.

    Parameters
    ----------
    psi0 : 2 dimensional complex ndarray
        The initial NORMALIZED wave function for the particles
    x : 1 dimensional double ndarray
        The grid points along one dimension, of length Np
    L : double
        Half the box length
    Nt : integer
        Number of time steps to take
    dt : double
        The length of the time step
    Ntraj : integer
        The number of trajectories to compute, given the initial distribution based on psi0
    coeff_file : string
        The .txt file containing the coefficients for the basis expansion of psi.
    output : string
        The output file, in to which the trajectories are dumped as a numpy array (which can be loaded with np.load).
    
    Notes
    -----
    This code draws from a discrete distribution of initial positions. This is basically equivalent
    to binning the end result distribution, so you might as well do it beforehand. This saves some computation,
    as trajectories starting at the same point need to only be calculated once.
    &#34;&#34;&#34;
    def __init__(self,psi0, x, L, Nt, dt, Ntraj = 1000, coeff_file=&#34;coeffs_nowall.txt&#34;, output=&#34;trajs.npy&#34;):
        self.psi0 = psi0
        self.Np = len(x)
        self.x = x
        self.dx = x[1]-x[0]
        self.Ntraj = Ntraj
        self.dt = dt
        self.Nt = Nt
        self.L = L
        self.coeffs = np.loadtxt(coeff_file, dtype=complex)
        self.output = output
    def generate_initial_distribution(self):
        &#34;&#34;&#34;Generates the initial distribution of indices in the psi0 array. Looks a bit confusing, but easily understood
        by perusing the rv_discrete documentation
        
        Returns
        -------
        dist 
            The collection of indices randomly drawn based on the psi distribution, corresponding to initial starting positions.
        
        Notes
        -----
        Depends on the initial distribution being given, and thus shouldn&#39;t be called outside of the class.
        &#34;&#34;&#34;
        equilibrium = stats.rv_discrete(name=&#39;equilibrium&#39;, values=(np.arange(self.Np*self.Np).reshape((self.Np,self.Np)), np.abs(self.psi0)**2*self.dx*self.dx))
        return equilibrium.rvs(size=self.Ntraj)

    def calculate_trajectories(self):
        &#34;&#34;&#34;Calculates Nt trajectories, giving them weights according to how many particles start at the same position in the initial
        distribution.

        Returns
        -------
        output : .npy file
            The output is given in the form of a .npy file, which can then be later loaded with np.load.
            The file is indexed such that arr[0,:,:] contains the first trajectory, with arr[0,:,0] containing
            the sequence of x1 coordinates and arr[0,0,:] containing the x2 coordinates.
        &#34;&#34;&#34;
        R = self.generate_initial_distribution()
        Rx = np.array([np.count_nonzero(R==y) for y in np.arange(self.Np*self.Np)])
        Rxs = Rx.reshape((self.Np,self.Np)) # This now contains how many 
        trajectories = []
        for i in range(len(Rxs[0,:])):
            for j in range(len(Rxs[0,:])):
                if Rxs[i,j] != 0:
                    trajectories.append(Trajectory(self.psi0, self.x, self.Nt, self.dt, (i,j),  Rxs[i,j]))

        print(&#34;Number of different trajectories: &#34;, len(trajectories), &#34;, starting calculation..&#34;)
        traj_xs = []
        for i in trajectories:
            i.compute_trajectory()
            for k in range(i.get_weight()):
                traj_xs.append(i.get_trajectory())
        
        np.save(self.output,np.array(traj_xs))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="bohmian.BohmianSimulation.calculate_trajectories"><code class="name flex">
<span>def <span class="ident">calculate_trajectories</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates Nt trajectories, giving them weights according to how many particles start at the same position in the initial
distribution.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>output</code></strong> :&ensp;<code>.npy file</code></dt>
<dd>The output is given in the form of a .npy file, which can then be later loaded with np.load.
The file is indexed such that arr[0,:,:] contains the first trajectory, with arr[0,:,0] containing
the sequence of x1 coordinates and arr[0,0,:] containing the x2 coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_trajectories(self):
    &#34;&#34;&#34;Calculates Nt trajectories, giving them weights according to how many particles start at the same position in the initial
    distribution.

    Returns
    -------
    output : .npy file
        The output is given in the form of a .npy file, which can then be later loaded with np.load.
        The file is indexed such that arr[0,:,:] contains the first trajectory, with arr[0,:,0] containing
        the sequence of x1 coordinates and arr[0,0,:] containing the x2 coordinates.
    &#34;&#34;&#34;
    R = self.generate_initial_distribution()
    Rx = np.array([np.count_nonzero(R==y) for y in np.arange(self.Np*self.Np)])
    Rxs = Rx.reshape((self.Np,self.Np)) # This now contains how many 
    trajectories = []
    for i in range(len(Rxs[0,:])):
        for j in range(len(Rxs[0,:])):
            if Rxs[i,j] != 0:
                trajectories.append(Trajectory(self.psi0, self.x, self.Nt, self.dt, (i,j),  Rxs[i,j]))

    print(&#34;Number of different trajectories: &#34;, len(trajectories), &#34;, starting calculation..&#34;)
    traj_xs = []
    for i in trajectories:
        i.compute_trajectory()
        for k in range(i.get_weight()):
            traj_xs.append(i.get_trajectory())
    
    np.save(self.output,np.array(traj_xs))</code></pre>
</details>
</dd>
<dt id="bohmian.BohmianSimulation.generate_initial_distribution"><code class="name flex">
<span>def <span class="ident">generate_initial_distribution</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the initial distribution of indices in the psi0 array. Looks a bit confusing, but easily understood
by perusing the rv_discrete documentation</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dist </code></dt>
<dd>The collection of indices randomly drawn based on the psi distribution, corresponding to initial starting positions.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Depends on the initial distribution being given, and thus shouldn't be called outside of the class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_initial_distribution(self):
    &#34;&#34;&#34;Generates the initial distribution of indices in the psi0 array. Looks a bit confusing, but easily understood
    by perusing the rv_discrete documentation
    
    Returns
    -------
    dist 
        The collection of indices randomly drawn based on the psi distribution, corresponding to initial starting positions.
    
    Notes
    -----
    Depends on the initial distribution being given, and thus shouldn&#39;t be called outside of the class.
    &#34;&#34;&#34;
    equilibrium = stats.rv_discrete(name=&#39;equilibrium&#39;, values=(np.arange(self.Np*self.Np).reshape((self.Np,self.Np)), np.abs(self.psi0)**2*self.dx*self.dx))
    return equilibrium.rvs(size=self.Ntraj)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bohmian.Trajectory"><code class="flex name class">
<span>class <span class="ident">Trajectory</span></span>
<span>(</span><span>psi0, x, L, coeffs, Nt, dt, startind, weight)</span>
</code></dt>
<dd>
<div class="desc"><p>A class describing a single Bohmian trajectory with a given weight.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>psi0</code></strong> :&ensp;<code>2 dimensional complex ndarray</code></dt>
<dd>The initial wave function to start the simulation from.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>1 dimensional double ndarray</code></dt>
<dd>The grid points for the box along one dimensional. The other dimension is forced to be the same</dd>
<dt><strong><code>L</code></strong> :&ensp;<code>double</code></dt>
<dd>Half the length of the box.</dd>
<dt><strong><code>coeffs</code></strong> :&ensp;<code>2 dimensional complex ndarray</code></dt>
<dd>The coefficients for the basis expansion of psi.</dd>
<dt><strong><code>Nt</code></strong> :&ensp;<code>integer</code></dt>
<dd>Number of timesteps to take</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>double</code></dt>
<dd>Size of the timestep</dd>
<dt><strong><code>startind</code></strong> :&ensp;<code>integer tuple</code></dt>
<dd>The starting position index from the x-array.</dd>
<dt><strong><code>weight</code></strong> :&ensp;<code>integer</code></dt>
<dd>How many trajectories start from the same index.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The class computes the trajectory only on command; by default, it contains some information about the weight of the trajectory
(i.e. how many times the particle started in the initial position), the inital wave function and the coefficient required for
the expansion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trajectory():

    &#34;&#34;&#34;A class describing a single Bohmian trajectory with a given weight.

    Parameters
    ----------
    psi0 : 2 dimensional complex ndarray
        The initial wave function to start the simulation from.
    x : 1 dimensional double ndarray
        The grid points for the box along one dimensional. The other dimension is forced to be the same
    L : double
        Half the length of the box.
    coeffs : 2 dimensional complex ndarray
        The coefficients for the basis expansion of psi.
    Nt : integer
        Number of timesteps to take
    dt : double
        Size of the timestep
    startind : integer tuple
        The starting position index from the x-array. 
    weight : integer
        How many trajectories start from the same index.
    
    Notes
    -----
    The class computes the trajectory only on command; by default, it contains some information about the weight of the trajectory
    (i.e. how many times the particle started in the initial position), the inital wave function and the coefficient required for
    the expansion. 
    &#34;&#34;&#34;
    def __init__(self, psi0, x, L, coeffs, Nt, dt, startind, weight):
        self.weight = weight
        self.x = x
        self.pos = np.array([x[startind[0]],x[startind[1]]])
        self.dx = self.x[1]-self.x[0]
        self.dt = dt
        self.psi0 = psi0
        self.traj = [self.pos]
        self.Nt = Nt
        self.L = L
        self.coeffs = coeffs
        self.n_basis = len(coeffs[:,0])
    def plot_xs(self):
        &#34;&#34;&#34;this is a description of the plot thing.&#34;&#34;&#34;
        ntraj = np.array(self.traj)
        print(np.max(ntraj[:,0]))
        print(ntraj[:,0])
    
    def euler_step(self,step):
        xcoord = find_nearest(self.x,self.pos[0])
        ycoord = find_nearest(self.x,self.pos[1])
        psi = self.psis[:,:,step]
        k1 = np.nan_to_num((x_deriv(psi,xcoord,ycoord,self.dx)/psi[xcoord,ycoord]).imag )
        k2 = np.nan_to_num((y_deriv(psi,xcoord,ycoord,self.dx)/psi[xcoord,ycoord]).imag )
        return [self.pos[0] + self.dt * k1, self.pos[1] + self.dt * k2]

    def euler_step_cython(self):
        &#34;&#34;&#34;Take Euler method step in the trajectory calculation.

        Returns
        -------
        pos : tuple (double)
            The new coordinates of the particle in (x1,x2) space.

        &#34;&#34;&#34;
        x1 = self.pos[0]
        x2 = self.pos[1]
        psi = 0
        k1 = np.nan_to_num( (fp.basis2d_x1deriv(self.coeffs, x1, x2, self.L, self.n_basis)/psi).imag  )
        k2 = np.nan_to_num( (fp.basis2d_x2deriv(self.coeffs, x1, x2, self.L, self.n_basis)/psi).imag )
        return [self.pos[0] + self.dt * k1, self.pos[1] + self.dt * k2]
    
    def compute_trajectory(self):
        &#34;&#34;&#34;Computes the trajectory for Nt time steps.
        
        Notes
        -----
        This is an internal function that modifies the trajectory self.traj. That variable contains
        as a numpy array the positions of the particle at each timestamp.
        &#34;&#34;&#34;
        for i in range(self.Nt):
            self.pos = self.euler_step(i)
            self.traj.append(np.copy(self.pos))

    def get_trajectory(self):
        &#34;&#34;&#34;Returns the trajectory as a numpy array.
        
        Returns
        -------
        traj : 2 dimensional ndarray
            The trajectory.
        &#34;&#34;&#34;
        return np.array(self.traj)

    def get_weight(self):
        &#34;&#34;&#34;Returns the weight of this trajectory
        
        Returns
        -------
        weight : integer
            The weight of the trajectory, i.e. how many times the particle started at this position.
        &#34;&#34;&#34;
        return self.weight</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="bohmian.Trajectory.compute_trajectory"><code class="name flex">
<span>def <span class="ident">compute_trajectory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the trajectory for Nt time steps.</p>
<h2 id="notes">Notes</h2>
<p>This is an internal function that modifies the trajectory self.traj. That variable contains
as a numpy array the positions of the particle at each timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_trajectory(self):
    &#34;&#34;&#34;Computes the trajectory for Nt time steps.
    
    Notes
    -----
    This is an internal function that modifies the trajectory self.traj. That variable contains
    as a numpy array the positions of the particle at each timestamp.
    &#34;&#34;&#34;
    for i in range(self.Nt):
        self.pos = self.euler_step(i)
        self.traj.append(np.copy(self.pos))</code></pre>
</details>
</dd>
<dt id="bohmian.Trajectory.euler_step"><code class="name flex">
<span>def <span class="ident">euler_step</span></span>(<span>self, step)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def euler_step(self,step):
    xcoord = find_nearest(self.x,self.pos[0])
    ycoord = find_nearest(self.x,self.pos[1])
    psi = self.psis[:,:,step]
    k1 = np.nan_to_num((x_deriv(psi,xcoord,ycoord,self.dx)/psi[xcoord,ycoord]).imag )
    k2 = np.nan_to_num((y_deriv(psi,xcoord,ycoord,self.dx)/psi[xcoord,ycoord]).imag )
    return [self.pos[0] + self.dt * k1, self.pos[1] + self.dt * k2]</code></pre>
</details>
</dd>
<dt id="bohmian.Trajectory.euler_step_cython"><code class="name flex">
<span>def <span class="ident">euler_step_cython</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Take Euler method step in the trajectory calculation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pos</code></strong> :&ensp;<code>tuple (double)</code></dt>
<dd>The new coordinates of the particle in (x1,x2) space.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def euler_step_cython(self):
    &#34;&#34;&#34;Take Euler method step in the trajectory calculation.

    Returns
    -------
    pos : tuple (double)
        The new coordinates of the particle in (x1,x2) space.

    &#34;&#34;&#34;
    x1 = self.pos[0]
    x2 = self.pos[1]
    psi = 0
    k1 = np.nan_to_num( (fp.basis2d_x1deriv(self.coeffs, x1, x2, self.L, self.n_basis)/psi).imag  )
    k2 = np.nan_to_num( (fp.basis2d_x2deriv(self.coeffs, x1, x2, self.L, self.n_basis)/psi).imag )
    return [self.pos[0] + self.dt * k1, self.pos[1] + self.dt * k2]</code></pre>
</details>
</dd>
<dt id="bohmian.Trajectory.get_trajectory"><code class="name flex">
<span>def <span class="ident">get_trajectory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the trajectory as a numpy array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>traj</code></strong> :&ensp;<code>2 dimensional ndarray</code></dt>
<dd>The trajectory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_trajectory(self):
    &#34;&#34;&#34;Returns the trajectory as a numpy array.
    
    Returns
    -------
    traj : 2 dimensional ndarray
        The trajectory.
    &#34;&#34;&#34;
    return np.array(self.traj)</code></pre>
</details>
</dd>
<dt id="bohmian.Trajectory.get_weight"><code class="name flex">
<span>def <span class="ident">get_weight</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the weight of this trajectory</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>weight</code></strong> :&ensp;<code>integer</code></dt>
<dd>The weight of the trajectory, i.e. how many times the particle started at this position.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weight(self):
    &#34;&#34;&#34;Returns the weight of this trajectory
    
    Returns
    -------
    weight : integer
        The weight of the trajectory, i.e. how many times the particle started at this position.
    &#34;&#34;&#34;
    return self.weight</code></pre>
</details>
</dd>
<dt id="bohmian.Trajectory.plot_xs"><code class="name flex">
<span>def <span class="ident">plot_xs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>this is a description of the plot thing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_xs(self):
    &#34;&#34;&#34;this is a description of the plot thing.&#34;&#34;&#34;
    ntraj = np.array(self.traj)
    print(np.max(ntraj[:,0]))
    print(ntraj[:,0])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="bohmian.BohmianSimulation" href="#bohmian.BohmianSimulation">BohmianSimulation</a></code></h4>
<ul class="">
<li><code><a title="bohmian.BohmianSimulation.calculate_trajectories" href="#bohmian.BohmianSimulation.calculate_trajectories">calculate_trajectories</a></code></li>
<li><code><a title="bohmian.BohmianSimulation.generate_initial_distribution" href="#bohmian.BohmianSimulation.generate_initial_distribution">generate_initial_distribution</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bohmian.Trajectory" href="#bohmian.Trajectory">Trajectory</a></code></h4>
<ul class="two-column">
<li><code><a title="bohmian.Trajectory.compute_trajectory" href="#bohmian.Trajectory.compute_trajectory">compute_trajectory</a></code></li>
<li><code><a title="bohmian.Trajectory.euler_step" href="#bohmian.Trajectory.euler_step">euler_step</a></code></li>
<li><code><a title="bohmian.Trajectory.euler_step_cython" href="#bohmian.Trajectory.euler_step_cython">euler_step_cython</a></code></li>
<li><code><a title="bohmian.Trajectory.get_trajectory" href="#bohmian.Trajectory.get_trajectory">get_trajectory</a></code></li>
<li><code><a title="bohmian.Trajectory.get_weight" href="#bohmian.Trajectory.get_weight">get_weight</a></code></li>
<li><code><a title="bohmian.Trajectory.plot_xs" href="#bohmian.Trajectory.plot_xs">plot_xs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>